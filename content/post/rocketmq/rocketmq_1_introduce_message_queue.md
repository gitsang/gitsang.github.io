---
title: '消息队列简介'
description: ''
lead: ''
date: 2020-05-22T15:44:34+08:00
lastmod: 2020-05-22T15:44:34+08:00
draft: false
images: []
menu:
  docs:
    parent: 'rocketmq'
weight: 100
toc: true
---

## 1. MQ 的优缺点及对比

### 1.1 什么是 MQ

消息队列（Message Queue）是一种进程间通信或同一进程的不同线程间的通信方式，简单来说就是用来存储通信消息的队列。

### 1.2 为什么使用 MQ

解耦、异步、削峰

#### 1.2.1 解耦

传统模式的系统中，假设 A 系统需要将生产的数据发送给 B、C，那么只需要直接调用 B、C 提供的接口。但如果之后有新的系统 D 也需要这份数据，那 A 就必须修改代码调用 D 的接口，以后每添加一个需要 A 数据的系统，或是某个系统不需要接入 A 了，A 都需要修改代码，且当下游系统宕机还会对 A 也产生影响。

因此需要 MQ 中间件实现系统的解耦。A 只需要将数据发送到 MQ 里，其他系统如果需要可以对数据进行订阅，不需要了就取消订阅。这样 A 只需要编写消息生产的代码，A 也不再需要考虑其他系统的异常情况。

#### 1.2.2 异步

假设 A 系统向 B 发送一条消息需要 5ms，但 B 解析完成这条消息需要 200ms，传统模式中，A 调用 B 完成一条消息发送到返回，需要 205ms。在这个过程 A 系统浪费掉了 200ms 的时间。

使用消息队列后，A 系统只需要一股脑地将数据丢进消息队列，然后返回即可。这样只需要消耗向 MQ 传输数据的时间，让 B 慢慢地异步处理这些消息就行。这样能让 A 系统迅速完成工作，同时也不会长时间地占用连接。

#### 1.2.3 削峰

假设 A 系统稳定情况下，每秒能够处理几百个请求，正常地使用都是 OK 的。但是如果突然出现每秒几千的请求，可能系统就直接被打死了，按照传统的模式解决这种问题的方法只能是增加机器分担请求。

如果使用 MQ 则可以按照系统可承受的并发量慢慢拉取消息，而超过系统处理量的消息就积压在 MQ 中，等高峰期过去后再慢慢消费。

### 1.3 使用 MQ 的缺点

#### 1.3.1 可用性/可靠性下降

加入 MQ 后就需要考虑 MQ 挂掉后怎么办，无疑为整个系统增加了隐患。且还需要保证消息如何不重复生产，不重复消费，传输过程是否可能丢失等等

#### 1.3.2 系统复杂度增加

加入 MQ 后还需要考虑数据一致性问题，数据的时序性问题等等。

### 1.4 常见 MQ 对比

![常见MQ对比.png](https://raw.githubusercontent.com/gitsang/gallery/master/page/20200526114306.png)

---

## 参考

https://blog.csdn.net/yssycz/article/details/80133084

https://juejin.im/post/5b32044ef265da59654c3027
